blueprint:
  name: Battery Smart Charging (Agile + SoC + Plunge)
  description: >
    Smart control for a battery charger using Octopus Agile prices (via BottlecapDave).
    Event-driven: reacts to new Agile data and SoC changes.
    Automatically handles Europe/London time with DST.

alias: "Battery Smart Charging"

  domain: automation
  input:
    charger_switch:
      name: Charger switch
      description: Smart plug or relay that powers your charger
      selector:
        entity:
          domain: switch

    battery_soc:
      name: Battery SoC sensor (%)
      description: Sensor returning 0–100 (e.g. Victron, SmartShunt, BMS)
      selector:
        entity:
          domain: sensor

    battery_capacity:
      name: Battery capacity (kWh)
      description: Example: 7.17 (Fogstar 560Ah @ 12.8V)
      default: 7.17
      selector:
        number:
          min: 0.1
          step: 0.01

    charger_power:
      name: Charger output power (W)
      description: Example: 600
      default: 600
      selector:
        number:
          min: 10
          max: 10000
          step: 10

    charge_efficiency:
      name: Charge efficiency (0–1)
      description: Accounts for charger + conversion losses
      default: 0.92
      selector:
        number:
          min: 0.5
          max: 1
          step: 0.01

    target_soc:
      name: Target SoC (%)
      default: 80
      selector:
        number:
          min: 10
          max: 100
          step: 1

    tolerance:
      name: Target tolerance (%)
      description: Treat SoC within this band as close enough
      default: 3
      selector:
        number:
          min: 0
          max: 10
          step: 1

    critical_soc:
      name: Critical minimum SoC (%)
      description: Below this, charge immediately
      default: 20
      selector:
        number:
          min: 0
          max: 100
          step: 1

    lookahead_hours:
      name: Look-ahead horizon (hours)
      description: How far ahead to plan (24–72 typical)
      default: 48
      selector:
        number:
          min: 12
          max: 96
          step: 6

    price_sensor:
      name: BottlecapDave price entity
      description: Entity whose attributes include upcoming Agile half-hourly rates
      selector:
        entity:
          domain: sensor

    price_attribute:
      name: Price list attribute name
      default: rates
      selector:
        text:

    price_key:
      name: Price key within each item
      default: value_inc_vat
      selector:
        text:

    start_key:
      name: Slot start key
      default: start
      selector:
        text:

    end_key:
      name: Slot end key
      default: end
      selector:
        text:

    price_cap:
      name: Price cap (p/kWh)
      description: 0 disables the cap — above this, charging stops
      default: 0
      selector:
        number:
          min: 0
          step: 0.1

    plunge_threshold:
      name: Plunge threshold (p/kWh)
      description: At/under this price → FORCE ON
      default: 0
      selector:
        number:
          min: -10
          step: 0.1

mode: restart
max_exceeded: silent

trigger:
  - platform: state
    entity_id: !input price_sensor
  - platform: state
    entity_id: !input battery_soc

variables:
  soc: "{{ states(!input battery_soc) | float(0) }}"
  price_data: "{{ state_attr(!input price_sensor, !input price_attribute) }}"
  price_cap: !input price_cap
  plunge_threshold: !input plunge_threshold
  price_key: !input price_key
  start_key: !input start_key

  current_price: >
    {% set data = state_attr(!input price_sensor, !input price_attribute) %}
    {% if data is mapping or data is iterable %}
      {% set now_iso = now().isoformat() %}
      {% set valid = data | selectattr(start_key, 'defined') | list %}
      {% if valid | count > 0 %}
        {% set latest = valid | selectattr(start_key, '<=', now_iso) | list | last %}
        {% if latest is mapping and price_key in latest %}
          {{ latest[price_key] | float(999) }}
        {% else %}
          {{ states(!input price_sensor) | float(999) }}
        {% endif %}
      {% else %}
        {{ states(!input price_sensor) | float(999) }}
      {% endif %}
    {% else %}
      {{ states(!input price_sensor) | float(999) }}
    {% endif %}

condition: []

action:
  - choose:
      # Emergency charge if SoC critically low
      - conditions: "{{ soc <= !input critical_soc }}"
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input charger_switch
          - stop: "Charging: critical SoC ({{ soc }}%)"

      # Force on if price <= plunge threshold
      - conditions: "{{ current_price <= plunge_threshold }}"
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input charger_switch
          - stop: "Charging: plunge price ({{ current_price }}p)"

      # Turn off if price above cap
      - conditions: >
          {{ price_cap > 0 and current_price > price_cap }}
        sequence:
          - service: switch.turn_off
            target:
              entity_id: !input charger_switch
          - stop: "Charging stopped: price above cap ({{ current_price }}p)"

      # Normal target charging logic
      - conditions: "{{ soc < (!input target_soc - !input tolerance) }}"
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input charger_switch
          - stop: "Charging: below target ({{ soc }}%)"

    default:
      - service: switch.turn_off
        target:
          entity_id: !input charger_switch
      - stop: "Charging not required ({{ soc }}%)"

